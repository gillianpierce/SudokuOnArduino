Project Title:
S(arduin)oku 

Group Members:
Luke Slevinsky, Gillian Pierce

Description:
A sudoku puzzle will be presented to the user on the LCD display attached to the Arduino.
The user will be able to choose the difficulty level of the puzzle
(i.e. how many clues are given). The user will be able to navigate around the Sudoku board
using the joystick and enter guesses. When they think the board is solved they will be
able to have their solution checked by the python program.

The overall structure of the project can be broken down into 3 components:
generating a “random” puzzle for the user to solve, client-server style communication for
the solving process and the checking of the solution.

1. Based on the selected difficulty of the puzzle, the number of clues and clue locations
will be manipulated. From a solved sudoku board, a puzzle can be generated by “erasing” a
number of squares until the desired difficulty level is achieved.

2.The user will use the joystick to navigate around the board to fill-in the empty squares.
When the user wants to make a selection for a certain square they will press the joystick
and then use a potentiometer to select which digit they would like to put in the square.
When they have completed the board the user will press the end game button.

3.The verification of the solution will be done by representing the board as a coloured
graph where there is a vertex for each square and edges represent squares in the same row,
column or 3x3 box.

If we have adequate time and the other parts of the project are completed we will
implement a solve button so, if during the solving of the board the user gets stuck,
they can have the python program output the solved board for them.


Milestones:
1. (March 22nd) Menu screen and board manipulation using the Arduino. Interface for user
interaction with the LCD display, joystick, buttons and potentiometer will be implemented.

2. (March 29th) Finite state machine for client-server communication and completed board
to coloured graph process. A function that takes the information from the completed board
and creates a coloured graph will be implemented (like how the edmonton graph was created
in Exercise 2).

3. (April 5th) Implementation of the verification algorithm. The verification algorithm
will take the graph that was created from the solved board and iterate through the row,
column and box lists of the vertices to ensure that no vertices in the same row, column
or box have the same “colour”.

4. (April 12th) Bug-fixes and optimization. We will “clean-up” our code and implement
a solving function that when given an unfinished board, outputs the solution. Including a
README, commenting the code and rigorous testing.
